#!/usr/bin/env python3
import argparse
import http.server
import json
import os
import subprocess
import sys
import tarfile
import tempfile
import shutil
import cgi
from socketserver import ThreadingMixIn

# Default configuration
DEFAULT_PORT = 8473
DEFAULT_HOST = "0.0.0.0"
PKGDIR = "/var/cache/binpkgs"

class ThreadingHTTPServer(ThreadingMixIn, http.server.HTTPServer):
    """Handle requests in a separate thread."""

class PortageBuildHandler(http.server.BaseHTTPRequestHandler):
    def do_POST(self):
        if self.path != '/build':
            self.send_error(404, "Not Found")
            return

        # Create a temporary directory to store the client's config
        config_root = tempfile.mkdtemp(prefix="lantage-config-")

        try:
            # Parse the multipart/form-data using the standard cgi module
            form = cgi.FieldStorage(
                fp=self.rfile,
                headers=self.headers,
                environ={'REQUEST_METHOD': 'POST',
                         'CONTENT_TYPE': self.headers['Content-Type']}
            )

            # Get the JSON job description
            job_field = form['job']
            job = json.loads(job_field.file.read())
            packages = job.get("packages")

            # Get the config tarball and extract it
            config_field = form['config']
            with tarfile.open(fileobj=config_field.file, mode="r:gz") as tar:
                tar.extractall(path=config_root)
            
            if not os.path.isdir(os.path.join(config_root, "portage")):
                raise ValueError("Extracted tarball does not contain a 'portage' directory.")

            if not packages or not isinstance(packages, list):
                self._send_response(400, {"error": "Invalid payload. 'packages' list not found."})
                return

            print(f"Received job to build {len(packages)} package(s) using client config.")

            failed_packages, built_package_files = self._build_packages(packages, config_root)

            if failed_packages:
                self._send_response(500, {"error": "Build failed", "details": failed_packages})
                return

            if not built_package_files:
                self._send_response(404, {"error": "No binary packages were successfully built."})
                return

            self._send_tarball(built_package_files)

        except Exception as e:
            print(f"An internal error occurred: {e}", file=sys.stderr)
            self._send_response(500, {"error": str(e)})
        finally:
            shutil.rmtree(config_root)

    def _build_packages(self, packages, config_root):
        failed_packages = []
        built_package_files = []
        build_env = os.environ.copy()
        build_env["PORTAGE_CONFIGROOT"] = config_root

        for pkg in packages:
            print(f"Building: {pkg}")
            try:
                subprocess.run(
                    ["emerge", "--buildpkgonly", pkg],
                    check=True, capture_output=True, text=True, env=build_env
                )
                pkg_path = self._find_package_file(pkg)
                if pkg_path:
                    built_package_files.append(pkg_path)
                else:
                    failed_packages.append({"package": pkg, "error": "Binary not found after build."})
            except subprocess.CalledProcessError as e:
                print(f"Failed to build {pkg}:\n{e.stderr}", file=sys.stderr)
                failed_packages.append({"package": pkg, "error": e.stderr})
        return failed_packages, built_package_files

    def _send_tarball(self, file_paths):
        with tempfile.NamedTemporaryFile(delete=False, suffix=".tar.gz") as tmp:
            tarball_path = tmp.name
        
        try:
            with tarfile.open(tarball_path, "w:gz") as tar:
                for f_path in file_paths:
                    tar.add(f_path, arcname=os.path.basename(f_path))
            
            self.send_response(200)
            self.send_header("Content-Type", "application/gzip")
            with open(tarball_path, 'rb') as f:
                fs = os.fstat(f.fileno())
                self.send_header("Content-Length", str(fs.st_size))
                self.end_headers()
                self.wfile.write(f.read())
        finally:
            os.remove(tarball_path)

    def _find_package_file(self, package_atom: str) -> str | None:
        try:
            category, pkgname_version = package_atom.split('/')
            pkg_dir = os.path.join(PKGDIR, category)
            if not os.path.isdir(pkg_dir):
                return None
            for f in os.listdir(pkg_dir):
                if f.startswith(pkgname_version) and (f.endswith(".tbz2") or f.endswith(".xpak")):
                    return os.path.join(pkg_dir, f)
        except ValueError: return None
        return None

    def _send_response(self, status_code: int, data: dict):
        self.send_response(status_code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode('utf-8'))

def main():
    parser = argparse.ArgumentParser(description="Lantage daemon to build packages remotely.")
    parser.add_argument("--host", default=DEFAULT_HOST, help=f"Hostname or IP to listen on (default: {DEFAULT_HOST})")
    parser.add_argument("--port", type=int, default=DEFAULT_PORT, help=f"Port to listen on (default: {DEFAULT_PORT})")
    args = parser.parse_args()

    if os.geteuid() != 0:
        print("Error: This daemon requires root privileges to run 'emerge'.\nPlease run as root, for example: # ./lantaged", file=sys.stderr)
        sys.exit(1)

    server_address = (args.host, args.port)
    httpd = ThreadingHTTPServer(server_address, PortageBuildHandler)
    print(f"Starting lantaged on {args.host}:{args.port}...")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down server.")
        httpd.server_close()

if __name__ == "__main__":
    main()