#!/usr/bin/env python3
import argparse
import http.server
import json
import os
import re
import subprocess
import sys
import tarfile
import tempfile
import shutil
from socketserver import ThreadingMixIn

# Default configuration
DEFAULT_PORT = 8473
DEFAULT_HOST = "0.0.0.0"
PKGDIR = "/var/cache/binpkgs"

class ThreadingHTTPServer(ThreadingMixIn, http.server.HTTPServer):
    """Handle requests in a separate thread."""

def parse_multipart(body: bytes, boundary: str):
    """A simple multipart/form-data parser to work on Python 3.13+ (no cgi)."""
    parts = body.split(boundary.encode('utf-8'))
    form = {}
    for part in parts:
        if b'Content-Disposition: form-data;' not in part:
            continue
        
        headers, content = part.split(b'\r\n\r\n', 1)
        content = content.rstrip(b'\r\n--') # Clean up trailing boundary markers
        
        name_match = b'name="'
        name_start = headers.find(name_match) + len(name_match)
        name_end = headers.find(b'"' , name_start)
        name = headers[name_start:name_end].decode('utf-8')
        
        # Store content and filename if present
        filename_match = b'filename="'
        if filename_match in headers:
            fn_start = headers.find(filename_match) + len(filename_match)
            fn_end = headers.find(b'"', fn_start)
            filename = headers[fn_start:fn_end].decode('utf-8')
            form[name] = {"filename": filename, "content": content}
        else:
            form[name] = {"content": content}
    return form

class PortageBuildHandler(http.server.BaseHTTPRequestHandler):
    def do_POST(self):
        if self.path != '/build':
            self.send_error(404, "Not Found")
            return

        config_root = tempfile.mkdtemp(prefix="lantage-config-")

        try:
            content_length = int(self.headers['Content-Length'])
            body = self.rfile.read(content_length)
            
            boundary = self.headers.get_boundary()
            if not boundary:
                self._send_response(400, {"error": "Invalid multipart/form-data request: no boundary"})
                return

            form = parse_multipart(body, boundary)

            job_data = form.get('job')
            if not job_data:
                self._send_response(400, {"error": "'job' field missing from request."})
                return
            
            job = json.loads(job_data['content'])
            packages = job.get("packages")

            config_data = form.get('config')
            if not config_data:
                self._send_response(400, {"error": "'config' field missing from request."})
                return

            with tempfile.NamedTemporaryFile() as tmp_tar:
                tmp_tar.write(config_data['content'])
                tmp_tar.seek(0)
                with tarfile.open(fileobj=tmp_tar, mode="r:gz") as tar:
                    tar.extractall(path=config_root)

            # Ensure make.profile is a symlink, respecting client's choice
            make_profile_path = os.path.join(config_root, "etc", "portage", "make.profile")
            
            if os.path.exists(make_profile_path) and not os.path.islink(make_profile_path):
                # Read the content of the client's make.profile (which is the target path)
                with open(make_profile_path, 'r') as f:
                    target_profile_content = f.read().strip()
                
                os.remove(make_profile_path) # Remove the invalid regular file
                os.makedirs(os.path.dirname(make_profile_path), exist_ok=True)
                # Create a symlink using the content of the original file as the target
                # os.path.normpath will resolve paths like "../../gentoo:default/linux/amd64/17.0"
                # relative to the symlink's location.
                os.symlink(target_profile_content, make_profile_path)
            elif not os.path.exists(make_profile_path):
                # If make.profile doesn't exist, create a default symlink
                os.makedirs(os.path.dirname(make_profile_path), exist_ok=True)
                os.symlink("/var/db/repos/gentoo/profiles/default/linux/amd64/23.0", make_profile_path)
            
            if not os.path.isdir(os.path.join(config_root, "portage")):
                raise ValueError("Extracted tarball does not contain a 'portage' directory.")

            print(f"Received job to build {len(packages)} package(s) using client config.")

            failed_packages, built_package_files = self._build_packages(packages, config_root)

            if failed_packages:
                self._send_response(500, {"error": "Build failed", "details": failed_packages})
                return

            if not built_package_files:
                self._send_response(404, {"error": "No binary packages were successfully built."})
                return

            self._send_tarball(built_package_files)

        except Exception as e:
            print(f"An internal error occurred: {e}", file=sys.stderr)
            self._send_response(500, {"error": str(e)})
        finally:
            shutil.rmtree(config_root)

    def _build_packages(self, packages, config_root):
        failed_packages = []
        built_package_files = []
        build_env = os.environ.copy()
        build_env["PORTAGE_CONFIGROOT"] = config_root

        for pkg in packages:
            print(f"Building: {pkg}")
            try:
                # Extract the package name without the version
                # This handles cases like 'x11-terms/alacritty-0.15.1' -> 'x11-terms/alacritty'
                # and 'dev-lang/python' -> 'dev-lang/python'
                package_name_only = re.sub(r'-[0-9].*$', '', pkg)
                subprocess.run(
                    ["emerge", "--buildpkgonly", package_name_only],
                    check=True, capture_output=True, text=True, env=build_env
                )
                pkg_path = self._find_package_file(pkg)
                if pkg_path:
                    built_package_files.append(pkg_path)
                else:
                    failed_packages.append({"package": pkg, "error": "Binary not found after build."})
            except subprocess.CalledProcessError as e:
                print(f"Failed to build {pkg}:\n{e.stderr}", file=sys.stderr)
                failed_packages.append({"package": pkg, "error": e.stderr})
        return failed_packages, built_package_files

    def _send_tarball(self, file_paths):
        with tempfile.NamedTemporaryFile(delete=False, suffix=".tar.gz") as tmp:
            tarball_path = tmp.name
        
        try:
            with tarfile.open(tarball_path, "w:gz") as tar:
                for f_path in file_paths:
                    tar.add(f_path, arcname=os.path.basename(f_path))
            
            self.send_response(200)
            self.send_header("Content-Type", "application/gzip")
            with open(tarball_path, 'rb') as f:
                fs = os.fstat(f.fileno())
                self.send_header("Content-Length", str(fs.st_size))
                self.end_headers()
                self.wfile.write(f.read())
        finally:
            os.remove(tarball_path)

    def _find_package_file(self, package_atom: str) -> str | None:
        try:
            category, pkgname_version = package_atom.split('/')
            pkg_dir = os.path.join(PKGDIR, category)
            if not os.path.isdir(pkg_dir):
                return None
            for f in os.listdir(pkg_dir):
                if f.startswith(pkgname_version) and (f.endswith(".tbz2") or f.endswith(".xpak")):
                    return os.path.join(pkg_dir, f)
        except ValueError: return None
        return None

    def _send_response(self, status_code: int, data: dict):
        self.send_response(status_code)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(data).encode('utf-8'))

def main():
    parser = argparse.ArgumentParser(description="Lantage daemon to build packages remotely.")
    parser.add_argument("--host", default=DEFAULT_HOST, help=f"Hostname or IP to listen on (default: {DEFAULT_HOST})")
    parser.add_argument("--port", type=int, default=DEFAULT_PORT, help=f"Port to listen on (default: {DEFAULT_PORT})")
    args = parser.parse_args()

    if os.geteuid() != 0:
        print("Error: This daemon requires root privileges to run 'emerge'.\nPlease run as root, for example: # ./lantaged", file=sys.stderr)
        sys.exit(1)

    server_address = (args.host, args.port)
    httpd = ThreadingHTTPServer(server_address, PortageBuildHandler)
    print(f"Starting lantaged on {args.host}:{args.port}...")
    print("Server is running and waiting for build requests.")
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down server.")
        httpd.server_close()

if __name__ == "__main__":
    main()